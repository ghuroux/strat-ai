/**
 * Playbook Types - Discovery-First Commerce Automation
 *
 * Playbooks are versioned JSON documents that describe how to interact with
 * e-commerce sites. They are generated by AI discovery and used by Playwright
 * automation, replacing brittle hardcoded selectors.
 *
 * @see docs/DISCOVERY_FIRST_ARCHITECTURE.md
 */

import type { SiteId } from '../types';

// ============================================================================
// Core Element Selection
// ============================================================================

/**
 * Bounding box for element location on screen
 * Used for visual fallback when CSS selectors fail
 */
export interface BoundingBox {
  x: number;
  y: number;
  width: number;
  height: number;
}

/**
 * Robust element selector with multiple fallback strategies
 *
 * Selection priority:
 * 1. Try primary CSS selector
 * 2. Try each fallback selector in order
 * 3. Use visual description with Claude vision as last resort
 */
export interface ElementSelector {
  /** Best CSS selector - most reliable, data-ref attributes preferred */
  primary: string;

  /** Backup CSS selectors in priority order */
  fallbacks: string[];

  /** Human-readable description for visual matching
   * @example "Green button with white text saying 'Add to Cart'"
   */
  visualDescription: string;

  /** Screenshot filename showing this element (highlighted if possible) */
  screenshot?: string;

  /** Last known position - helpful for visual matching */
  boundingBox?: BoundingBox;

  /** Confidence score from discovery (0-1)
   * - 1.0: data-ref attribute found
   * - 0.8: unique CSS selector found
   * - 0.5: multiple possible matches, picked best
   * - 0.3: only visual description available
   */
  confidence: number;
}

// ============================================================================
// Authentication
// ============================================================================

/**
 * Authentication flow configuration
 * Describes how to detect login state and perform login
 */
export interface AuthConfig {
  /** URL of the login page */
  loginUrl: string;

  /** Elements that indicate user IS logged in
   * @example Account name, user avatar, "My Account" link
   */
  loggedInIndicators: ElementSelector[];

  /** Elements that indicate user is NOT logged in
   * @example "Login" link, "Sign In" button
   */
  loggedOutIndicators: ElementSelector[];

  /** Login form field selectors */
  loginForm: {
    emailInput: ElementSelector;
    passwordInput: ElementSelector;
    submitButton: ElementSelector;
  };

  /** Reference screenshots for each auth state */
  screenshots: {
    loggedIn: string;
    loggedOut: string;
    loginPage: string;
  };
}

// ============================================================================
// User Flows
// ============================================================================

/**
 * Action types for flow steps
 */
export type FlowAction =
  | 'navigate'  // Go to URL
  | 'click'     // Click element
  | 'type'      // Enter text
  | 'wait'      // Wait for element or time
  | 'extract'   // Extract data from page
  | 'scroll'    // Scroll to element or position
  | 'hover';    // Hover over element

/**
 * Failure handling strategy for flow steps
 */
export type FailureStrategy =
  | 'skip'    // Continue to next step (optional step)
  | 'retry'   // Retry this step (up to 3 times)
  | 'abort';  // Stop flow and report error

/**
 * Single step in a user flow
 */
export interface FlowStep {
  /** Unique identifier for this step */
  id: string;

  /** Human-readable step description */
  name: string;

  /** Action to perform */
  action: FlowAction;

  /** Target element (required for click, type, scroll, hover) */
  target?: ElementSelector;

  /** Value to use (URL for navigate, text for type) */
  value?: string;

  /** Wait condition (element selector or milliseconds) */
  waitFor?: ElementSelector | number;

  /** What to do if this step fails */
  onFailure: FailureStrategy;

  /** Data to extract (for extract action) */
  extractAs?: string;
}

/**
 * Complete user flow (search, add-to-cart, checkout, etc.)
 */
export interface Flow {
  /** Flow identifier */
  name: string;

  /** Human-readable description */
  description: string;

  /** Ordered steps to complete the flow */
  steps: FlowStep[];

  /** Elements that indicate flow succeeded */
  successIndicators: ElementSelector[];

  /** Elements that indicate flow failed */
  failureIndicators: ElementSelector[];
}

// ============================================================================
// Popup Handling
// ============================================================================

/**
 * Popup/modal pattern that may interrupt flows
 * @example Cookie consent banners, newsletter modals, GDPR notices
 */
export interface PopupPattern {
  /** Human-readable name for this popup */
  name: string;

  /** How to detect this popup is present */
  detection: ElementSelector;

  /** How to dismiss the popup */
  dismissAction: {
    type: 'click' | 'key';
    /** Element to click (for click type) */
    target?: ElementSelector;
    /** Key to press (for key type) */
    key?: string;
  };

  /** Priority - lower numbers are handled first */
  priority: number;
}

// ============================================================================
// Search Configuration
// ============================================================================

/**
 * Search functionality configuration
 */
export interface SearchConfig {
  /** Search input field */
  searchInput: ElementSelector;

  /** Search submit button (optional - may use Enter key) */
  searchButton?: ElementSelector;

  /** Container for search results */
  resultsContainer: ElementSelector;

  /** Individual product card in results */
  productCard: ElementSelector;

  /** Selectors for extracting product data from cards */
  productData: {
    name: ElementSelector;
    price: ElementSelector;
    link: ElementSelector;
    image?: ElementSelector;
    rating?: ElementSelector;
    reviewCount?: ElementSelector;
  };

  /** Pagination controls */
  pagination?: {
    nextButton: ElementSelector;
    pageIndicator?: ElementSelector;
  };
}

// ============================================================================
// Product Page Configuration
// ============================================================================

/**
 * Product detail page configuration
 */
export interface ProductPageConfig {
  /** Product name/title */
  name: ElementSelector;

  /** Current price */
  price: ElementSelector;

  /** Main product image */
  image: ElementSelector;

  /** Rating display */
  rating?: ElementSelector;

  /** Review count */
  reviewCount?: ElementSelector;

  /** Stock status indicator */
  stockStatus?: ElementSelector;

  /** Out of stock indicators */
  outOfStockIndicators: ElementSelector[];

  /** Add to cart button */
  addToCart: ElementSelector;

  /** Quantity selector (if present) */
  quantityInput?: ElementSelector;

  /** Variant selectors (size, color, etc.) */
  variants?: {
    name: string;
    selector: ElementSelector;
  }[];
}

// ============================================================================
// Cart & Checkout Configuration
// ============================================================================

/**
 * Shopping cart configuration
 */
export interface CartConfig {
  /** Cart icon/link in header */
  cartIcon: ElementSelector;

  /** Cart item count badge */
  cartCount?: ElementSelector;

  /** Cart page URL pattern */
  cartUrl: string;

  /** Individual cart item */
  cartItem: ElementSelector;

  /** Cart item data extraction */
  cartItemData: {
    name: ElementSelector;
    price: ElementSelector;
    quantity: ElementSelector;
    image?: ElementSelector;
  };

  /** Remove item button (within cart item) */
  removeButton: ElementSelector;

  /** Cart subtotal */
  subtotal: ElementSelector;

  /** Proceed to checkout button */
  checkoutButton: ElementSelector;
}

/**
 * Checkout flow configuration
 */
export interface CheckoutConfig {
  /** Checkout page URL pattern */
  checkoutUrl: string;

  /** Shipping address section */
  shippingAddress?: {
    container: ElementSelector;
    useExisting?: ElementSelector;
    addNew?: ElementSelector;
  };

  /** Payment method section */
  paymentMethod?: {
    container: ElementSelector;
    savedPayment?: ElementSelector;
    addNewPayment?: ElementSelector;
  };

  /** Order summary on checkout */
  orderSummary: {
    subtotal: ElementSelector;
    shipping: ElementSelector;
    tax?: ElementSelector;
    total: ElementSelector;
  };

  /** Place order / confirm purchase button */
  placeOrderButton: ElementSelector;

  /** Order confirmation page indicators */
  confirmationIndicators: ElementSelector[];

  /** Order ID extraction */
  orderIdSelector?: ElementSelector;
}

// ============================================================================
// Site Playbook
// ============================================================================

/**
 * Complete site playbook - single source of truth for site automation
 *
 * Generated by discovery agent, used by PlaybookAdapter.
 * Version controlled in /playbooks/{siteId}/{version}/
 */
export interface SitePlaybook {
  // -- Metadata --

  /** Unique playbook identifier (UUID) */
  id: string;

  /** Site this playbook is for */
  siteId: SiteId;

  /** Semantic version (e.g., "1.0.0") */
  version: string;

  /** When playbook was first created */
  createdAt: string;

  /** When playbook was last updated */
  updatedAt: string;

  /** Discovery session ID that generated this playbook */
  discoverySessionId?: string;

  // -- Site Configuration --

  /** Site's base URL */
  baseUrl: string;

  /** Optional user agent to use */
  userAgent?: string;

  /** Default timeout for page operations (ms) */
  defaultTimeout: number;

  // -- Core Configurations --

  /** Authentication configuration */
  auth: AuthConfig;

  /** Search functionality */
  search: SearchConfig;

  /** Product detail pages */
  productPage: ProductPageConfig;

  /** Shopping cart */
  cart: CartConfig;

  /** Checkout process */
  checkout: CheckoutConfig;

  // -- Flows --

  /** Custom flows for complex operations */
  flows: {
    search: Flow;
    addToCart: Flow;
    checkout: Flow;
    [key: string]: Flow;
  };

  // -- Popup Handling --

  /** Known popup patterns to dismiss */
  popups: PopupPattern[];

  // -- Validation --

  /** Last validation timestamp */
  lastValidatedAt?: string;

  /** Last validation result */
  lastValidationResult?: {
    passed: boolean;
    failedSelectors: string[];
    timestamp: string;
  };
}

// ============================================================================
// Discovery Types
// ============================================================================

/**
 * Discovery session status
 */
export type DiscoveryStatus =
  | 'initializing'
  | 'exploring'
  | 'discovering_auth'
  | 'discovering_search'
  | 'discovering_cart'
  | 'discovering_checkout'
  | 'generating_playbook'
  | 'completed'
  | 'failed';

/**
 * Active discovery session
 */
export interface DiscoverySession {
  /** Session ID */
  id: string;

  /** Site being discovered */
  siteId: SiteId;

  /** Current status */
  status: DiscoveryStatus;

  /** When session started */
  startedAt: string;

  /** Progress updates */
  progress: DiscoveryProgress[];

  /** Partial playbook being built */
  partialPlaybook?: Partial<SitePlaybook>;

  /** Screenshots taken during discovery */
  screenshots: DiscoveryScreenshot[];

  /** Any errors encountered */
  errors: DiscoveryError[];
}

/**
 * Discovery progress update
 */
export interface DiscoveryProgress {
  timestamp: string;
  phase: DiscoveryStatus;
  message: string;
  screenshotId?: string;
}

/**
 * Screenshot taken during discovery
 */
export interface DiscoveryScreenshot {
  id: string;
  filename: string;
  phase: DiscoveryStatus;
  description: string;
  timestamp: string;
}

/**
 * Error during discovery
 */
export interface DiscoveryError {
  timestamp: string;
  phase: DiscoveryStatus;
  message: string;
  recoverable: boolean;
}

// ============================================================================
// Validation Types
// ============================================================================

/**
 * Result of validating a single selector
 */
export interface SelectorValidation {
  /** Path to selector in playbook (e.g., "auth.loginForm.emailInput") */
  path: string;

  /** The selector being validated */
  selector: ElementSelector;

  /** Whether primary selector found element */
  primaryValid: boolean;

  /** Which fallback selectors worked (indices) */
  validFallbacks: number[];

  /** Current element screenshot (if found) */
  currentScreenshot?: string;

  /** Whether element looks visually different */
  visuallyChanged?: boolean;
}

/**
 * Complete playbook validation result
 */
export interface PlaybookValidation {
  /** Playbook that was validated */
  playbookId: string;

  /** Overall pass/fail */
  passed: boolean;

  /** Validation timestamp */
  timestamp: string;

  /** Individual selector validations */
  selectorResults: SelectorValidation[];

  /** Summary statistics */
  summary: {
    totalSelectors: number;
    validSelectors: number;
    brokenSelectors: number;
    visuallyChanged: number;
  };

  /** Recommendation based on results */
  recommendation: 'ok' | 'update_selectors' | 'rediscover';
}
