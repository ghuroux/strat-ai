# Ralph Progress Log

## Feature: Page Listing Access Control Fix
**Parent Task:** page-listing-access-fix
**Started:** 2026-01-16
**Status:** Ready to begin

## Problem Statement

When pages have `visibility = 'area'`, area members cannot see them in `findAll()` because the query only checks `user_id = ${userId}`. However, `findById()` works correctly because it uses `canAccessPage()` for full access control.

## Decisions Made During PRD Creation

- No blockers or clarifications needed - spec is complete and detailed
- Solution: Use CTE-based query pattern (same as areas-postgres.ts findAllAccessible)
- No database schema changes required - query logic fix only
- Estimated effort: 1-1.5 hours total

## Codebase Patterns Discovered

- **CTE pattern:** `areas-postgres.ts` → `findAllAccessible()` uses exact same pattern with UNION for multiple access paths
- **Access control algorithm:** `page-sharing-postgres.ts` → `canAccessPage()` defines the 5 access pathways that must be replicated
- **postgres.js conventions:** All column access uses camelCase (e.g., `row.userId` not `row.user_id`)

## Access Paths to Implement (from spec)

| Priority | Condition | Permission Source |
|----------|-----------|-------------------|
| 1 | User owns page (`user_id = userId`) | owner |
| 2 | `visibility = 'private'` + direct user share | user_share |
| 3 | `visibility = 'private'` + group share | group_share |
| 4 | `visibility = 'area'` + user has area access | area |
| 5 | `visibility = 'space'` + user owns space | space |

## Stories

| ID | Title | Status |
|----|-------|--------|
| US-001 | Update findAll() with CTE-based access control | completed |
| US-002 | Update search() with access control | completed |
| US-003 | Update count() with access control | completed |
| US-004 | Manual testing and verification | pending |

---

## Iteration Log

(Each iteration appends a section below)

### Iteration 1: US-001 - Update findAll() with CTE-based access control
**Date:** 2026-01-16
**Status:** Completed

**What was done:**
- Created `buildAccessiblePagesCTE()` helper function that returns a PostgreSQL CTE for accessible page IDs
- The CTE implements 5 access paths via UNION:
  1. Path 1: User owns the page (`user_id = userId`)
  2. Path 2: Private page with direct user share (via `page_user_shares`)
  3. Path 3: Private page with group share (via `page_group_shares` + `group_memberships`)
  4. Path 4: Area-visible page where user has area access (mirrors `canAccessArea` logic)
  5. Path 5: Space-visible page where user owns the space
- Updated `findAll()` to use the CTE with all filter combinations (areaId, pageType, taskId)
- Added proper JSDoc documentation to the function

**Files changed:**
- `src/lib/server/persistence/pages-postgres.ts` - Added CTE helper and updated `findAll()`

**Patterns applied:**
- CTE with UNION pattern from `areas-postgres.ts` → `findAllAccessible()`
- postgres.js camelCase transformation (all column access uses camelCase)
- Access control mirrors `page-sharing-postgres.ts` → `canAccessPage()` algorithm

**Quality gates:**
- ✅ `npm run check` - 0 TypeScript errors
- ✅ `npm run audit-db-access` - 0 violations
- ⚠️ `npm run lint` - Pre-existing config issue (eslint.config.js missing for ESLint v9)

**Learnings:**
1. **CTE composition with postgres.js**: The `PendingQuery<Row[]>` type allows creating reusable SQL fragments that can be composed with template literals. Import from `postgres`.
2. **Area access is complex**: Path 4 (area visibility) required handling 5 different ways a user can access an area: creator, direct membership, group membership, space owner, or non-restricted area with space membership.
3. **Deleted area handling**: The CTE checks `a.deleted_at IS NULL` in Path 4 to prevent showing pages from deleted areas (owners already have access via Path 1).
4. **Guest role exclusion**: Non-restricted areas only grant access to space members with role IN ('owner', 'admin', 'member'), excluding 'guest'.

**Decision:** Used `IN (SELECT id FROM accessible_pages)` instead of JOIN for readability and to avoid duplicate rows when a page is accessible via multiple paths.

### Iteration 2: US-002 - Update search() with access control
**Date:** 2026-01-16
**Status:** Completed

**What was done:**
- Updated `search()` method to use `buildAccessiblePagesCTE()` helper function from US-001
- Replaced simple `WHERE user_id = ${userId}` check with CTE-based access control
- Added table alias `p` to disambiguate columns in JOIN with CTE
- Preserved full-text search functionality using PostgreSQL `to_tsvector` and `to_tsquery`
- Preserved search ranking using `ts_rank()` for relevance ordering
- Maintained support for area-specific searches via `areaId` filter

**Files changed:**
- `src/lib/server/persistence/pages-postgres.ts` - Updated `search()` method

**Acceptance criteria verified:**
- ✅ Reuses `buildAccessiblePagesCTE()` helper from US-001
- ✅ search() filters results through accessible pages CTE
- ✅ Search only returns pages user can access (via CTE)
- ✅ Search within specific area respects access control
- ✅ Full-text search functionality still works correctly
- ✅ Search ranking is preserved (`ORDER BY ts_rank(...)`)

**Quality gates:**
- ✅ `npm run check` - 0 TypeScript errors
- ✅ `npm run audit-db-access` - 0 violations
- ⚠️ `npm run lint` - Pre-existing config issue (eslint.config.js missing for ESLint v9)

**Learnings:**
1. **CTE reuse is straightforward**: The `buildAccessiblePagesCTE()` helper is designed for composition - just include it in the `WITH` clause and filter via `IN (SELECT id FROM accessible_pages)`.
2. **Table aliases required**: When using the CTE with other query conditions, table aliases (`p.`) are needed to disambiguate column references.
3. **Full-text search unaffected**: The access control change is orthogonal to the search functionality - the CTE filters the result set before ranking.

**Pattern:** For any method that retrieves pages and filters by `user_id = ${userId}`, the fix is the same: add `WITH ${accessiblePagesCTE}` and change `WHERE user_id = ${userId}` to `WHERE p.id IN (SELECT id FROM accessible_pages)`.

---

### Iteration 3: US-003 - Update count() with access control
**Date:** 2026-01-16
**Status:** Completed

**What was done:**
- Updated `count()` method to use `buildAccessiblePagesCTE()` helper function from US-001
- Replaced simple `WHERE user_id = ${userId}` check with CTE-based access control
- Added table alias `p` to disambiguate columns in query with CTE
- Preserved support for `areaId` filter
- Added JSDoc documentation to match `findAll()` and `search()`

**Files changed:**
- `src/lib/server/persistence/pages-postgres.ts` - Updated `count()` method (lines 627-664)

**Acceptance criteria verified:**
- ✅ Reuses `buildAccessiblePagesCTE()` helper from US-001
- ✅ count() filters through accessible pages CTE
- ✅ Count returns accurate number of accessible pages (via CTE)
- ✅ Count with areaId filter is accurate
- ✅ `npm run check` passes (0 errors, 160 warnings - all pre-existing)
- ⚠️ `npm run lint` - Pre-existing config issue (eslint.config.js missing for ESLint v9)

**Quality gates:**
- ✅ `npm run check` - 0 TypeScript errors
- ✅ `npm run audit-db-access` - 0 violations
- ⚠️ `npm run lint` - Pre-existing config issue (eslint.config.js missing for ESLint v9)

**Learnings:**
1. **Pattern repetition confirms design**: The exact same pattern (`WITH ${accessiblePagesCTE}` + `WHERE p.id IN (SELECT id FROM accessible_pages)`) worked unchanged for `count()`, validating the CTE helper design.
2. **Minimal change principle**: Only 2 changes needed: (1) add CTE to WITH clause, (2) change filter from `user_id = ${userId}` to `p.id IN (SELECT id FROM accessible_pages)`.
3. **Consistency across methods**: All three methods (`findAll`, `search`, `count`) now use identical access control logic, ensuring UI counters match list content.

**Pattern confirmed:** For any page query method that uses `user_id = ${userId}`:
```typescript
// Before (simple owner check)
const result = await sql`
  SELECT ... FROM pages WHERE user_id = ${userId} ...
`;

// After (full access control)
const accessiblePagesCTE = buildAccessiblePagesCTE(userId);
const result = await sql`
  WITH ${accessiblePagesCTE}
  SELECT ... FROM pages p WHERE p.id IN (SELECT id FROM accessible_pages) ...
`;
```

---
