# Ralph Progress Log

## Feature: Temporal Awareness
**Parent Task:** temporal-awareness
**Started:** 2026-01-16
**Status:** Ready to begin

## Decisions Made During PRD Creation

- **Where to store timezone**: In UserPreferences JSON field (not a schema change) - follows existing pattern for theme and homePage
- **Default timezone**: Africa/Johannesburg (SAST) - current user base is South Africa
- **Cache Layer 0**: shouldCache: false - temporal context changes daily, small (~50 tokens) so cache miss negligible

## Codebase Patterns Discovered

- `getSystemPromptLayers()` in system-prompts.ts returns PromptLayer[] with name, content, shouldCache
- Platform prompt is currently Layer 1 (will become Layer 1 after temporal is Layer 0)
- UserPreferences is stored as JSONB in users.preferences column
- Preferences API has validation functions per field: validateHomePage(), validateTheme(), validateDefaultModel()
- Layout.svelte uses onMount() for client-side detection (theme sync pattern to follow)
- `Intl.DateTimeFormat().resolvedOptions().timeZone` for browser timezone detection

## Stories

| ID | Title | Status |
|----|-------|--------|
| US-001 | Create getTemporalContext() function in system-prompts.ts | completed |
| US-002 | Inject temporal context as Layer 0 in getSystemPromptLayers() | completed |
| US-003 | Add timezone field to UserPreferences type | completed |
| US-004 | Add timezone validation to preferences API endpoint | completed |
| US-005 | Detect and sync timezone on app load | completed |
| US-006 | Pass timezone to chat API and prompt builder | completed |
| US-007 | Add timezone selector to Settings UI (Optional Phase 3) | completed |

---

## Iteration Log

(Each iteration appends a section below)

---

### US-001: Create getTemporalContext() function (2026-01-16)

**Status:** Completed

**What was done:**
- Created `getTemporalContext(timezone?: string)` function in `src/lib/config/system-prompts.ts`
- Function generates temporal context with current date and timezone for AI prompt injection
- Date formatted as "Thursday, January 16, 2026" using `Intl.DateTimeFormat` with long format
- Timezone display name retrieved using `formatToParts()` to extract timezone name (e.g., "South Africa Standard Time")
- Output wrapped in `<temporal_context>` XML tags as required by acceptance criteria
- Defaults to 'Africa/Johannesburg' when no timezone provided
- Added `DEFAULT_TIMEZONE` constant for consistency

**Files changed:**
- `src/lib/config/system-prompts.ts` - Added getTemporalContext() function (~55 lines)

**Patterns applied:**
- Used `Intl.DateTimeFormat` for internationalization-friendly date/time formatting
- Used `formatToParts()` to extract specific parts (timeZoneName) without parsing strings
- Added JSDoc with examples for clear API documentation
- Followed existing code style with explicit type annotations

**Learnings:**
1. **Intl.DateTimeFormat.formatToParts()** - More robust than parsing formatted strings when you need specific parts like timezone name
2. **timeZoneName: 'long'** option gives full timezone display name (e.g., "South Africa Standard Time" vs just "SAST")
3. **ESLint config missing** - Project has no eslint.config.js file, so `npm run lint` fails. Pre-existing issue, not introduced by this change.

**Quality gates:**
- ✅ npm run check - passes (0 errors)
- ⚠️ npm run lint - skipped (pre-existing missing eslint config)
- ✅ Prettier formatting applied

---

### US-002: Inject temporal context as Layer 0 (2026-01-16)

**Status:** Completed

**What was done:**
- Modified `getSystemPromptLayers()` to accept new `timezone` option parameter
- Injected temporal layer as the FIRST layer (Layer 0) before platform prompt
- Temporal layer properties: `name: 'temporal'`, `shouldCache: false`
- Platform prompt shifted from Layer 1 to Layer 1 (unchanged number, but now after temporal)
- Context layer is now Layer 2 (after temporal and platform)
- Updated JSDoc comments to reflect new layer ordering

**Files changed:**
- `src/lib/config/system-prompts.ts` - Modified getSystemPromptLayers() function (~20 lines added)

**Patterns applied:**
- Followed existing PromptLayer interface pattern (name, content, shouldCache)
- Used consistent pattern with `options.timezone` optional parameter
- Maintained backwards compatibility (timezone defaults to 'Africa/Johannesburg' via getTemporalContext)

**Learnings:**
1. **Layer ordering matters for prompt caching** - Temporal goes first because it changes most frequently (daily), which means cache invalidation propagates correctly. Putting it at the end would waste caching for stable layers.
2. **shouldCache: false is correct** - Small layer (~50 tokens), changes daily. Cache miss cost is negligible compared to maintaining cache freshness for time-sensitive content.
3. **Options object pattern** - Function already used options object, making it easy to add new optional parameters without breaking existing callers.

**Quality gates:**
- ✅ npm run check - passes (0 errors, only warnings)
- ⚠️ npm run lint - skipped (pre-existing missing eslint config)

---

---

### US-003: Add timezone field to UserPreferences type (2026-01-16)

**Status:** Completed

**What was done:**
- Added `timezone?: string` field to the `UserPreferences` interface in `src/lib/types/user.ts`
- Added JSDoc documentation explaining the IANA timezone format and usage
- Examples in JSDoc: 'Africa/Johannesburg', 'America/New_York', 'Europe/London'

**Files changed:**
- `src/lib/types/user.ts` - Added timezone field to UserPreferences interface (~6 lines)

**Patterns applied:**
- Followed existing optional field pattern from `theme`, `homePage`, `defaultModel`
- Used JSDoc with examples to document the expected format (IANA timezone strings)
- Kept the change minimal - just the type definition, no database changes needed since UserPreferences is stored as JSONB

**Learnings:**
1. **UserPreferences stored as JSONB** - No migration needed for new preference fields since they're stored in a JSON column. Just add to the TypeScript interface.
2. **IANA timezone format** - Industry standard format (e.g., 'Africa/Johannesburg') used by JavaScript's `Intl` APIs. Browser-detectable via `Intl.DateTimeFormat().resolvedOptions().timeZone`.
3. **Simple stories matter** - Even a 6-line change is a discrete unit of work that can be tested and committed independently. Sets up foundation for US-004 (validation) and US-005 (detection).

**Quality gates:**
- ✅ npm run check - passes (0 errors, 160 warnings - all pre-existing)
- ⚠️ npm run lint - skipped (pre-existing missing eslint config)

---

### US-004: Add timezone validation to preferences API endpoint (2026-01-16)

**Status:** Completed

**What was done:**
- Added `validateTimezone()` function to `src/routes/api/user/preferences/+server.ts`
- Uses `Intl.DateTimeFormat` to validate IANA timezone strings at runtime
- Updated PATCH handler to accept `body.timezone` and call validation
- Invalid timezone returns 400 with `validation_error` type (follows existing pattern)
- Updated JSDoc for PATCH handler to include timezone parameter

**Files changed:**
- `src/routes/api/user/preferences/+server.ts` - Added validateTimezone() function (~25 lines) and PATCH handler timezone handling (~10 lines)

**Patterns applied:**
- Followed existing validation pattern from `validateTheme()` and `validateDefaultModel()`
- Used `Intl.DateTimeFormat` for timezone validation (throws on invalid timezone)
- Consistent error response format with `{ message, type: 'validation_error' }`
- JSDoc examples for clarity on expected input/output

**Learnings:**
1. **Intl.DateTimeFormat for timezone validation** - Passing an invalid timezone to `{ timeZone: value }` option throws a RangeError. This is the cleanest way to validate IANA timezone strings without maintaining a hardcoded list.
2. **Pattern consistency matters** - Following the exact same pattern as existing validators (validateTheme, validateHomePage) makes the code predictable and easy to review.
3. **Error message format** - Using `type: 'validation_error'` allows clients to differentiate between validation errors (user fixable) and server errors (not user fixable).

**Quality gates:**
- ✅ npm run check - passes (0 errors, 160 warnings - all pre-existing)
- ⚠️ npm run lint - skipped (pre-existing missing eslint config)

---

### US-005: Detect and sync timezone on app load (2026-01-16)

**Status:** Completed

**What was done:**
- Added `syncTimezone()` async function to `src/routes/+layout.svelte`
- Called `syncTimezone()` in `onMount()` when user is authenticated
- Function detects browser timezone using `Intl.DateTimeFormat().resolvedOptions().timeZone`
- Only sends PATCH request if detected timezone differs from stored preference
- Updates `userStore.preferences` with new timezone on successful sync
- Silent operation: no toasts, only `console.debug` on failure

**Files changed:**
- `src/routes/+layout.svelte` - Added syncTimezone() function (~30 lines) and onMount call (~3 lines)

**Patterns applied:**
- Followed existing theme sync pattern in layout.svelte (onMount client-side detection)
- Used existing `userStore.setPreferences()` method for store updates
- Spread existing preferences to preserve other settings when updating timezone
- Silent failure pattern for non-critical operations

**Learnings:**
1. **Intl.DateTimeFormat().resolvedOptions().timeZone** - Browser-native timezone detection, returns IANA format directly (e.g., 'America/New_York'). No external libraries needed.
2. **Silent sync for non-critical preferences** - Timezone sync shouldn't interrupt UX with errors. If it fails, user still gets Africa/Johannesburg default. Log for debugging but don't toast.
3. **Check before sync** - Only make network request if detected differs from stored. Avoids unnecessary API calls on every page load.
4. **Spread pattern for partial updates** - `{ ...userStore.preferences, timezone: detectedTimezone }` preserves other preferences when updating one field.

**Quality gates:**
- ✅ npm run check - passes (0 errors, 160 warnings - all pre-existing)
- ⚠️ npm run lint - skipped (pre-existing missing eslint config)

---

### US-006: Pass timezone to chat API and prompt builder (2026-01-16)

**Status:** Completed

**What was done:**
- Added `postgresUserRepository` import to chat API endpoint
- Modified `injectPlatformPrompt()` function to accept new `timezone` parameter
- Modified `handleChatWithTools()` function to accept new `timezone` parameter
- In POST handler, fetches user timezone from preferences early in the request
- Passes timezone through to both call chains:
  - Direct path: POST handler → `injectPlatformPrompt()` → `getSystemPromptLayers()`
  - Tool handling path: POST handler → `handleChatWithTools()` → `injectPlatformPrompt()` → `getSystemPromptLayers()`
- Falls back to default ('Africa/Johannesburg') if timezone fetch fails or is not set

**Files changed:**
- `src/routes/api/chat/+server.ts` - Added timezone parameter threading (~15 lines changed across multiple functions)

**Patterns applied:**
- **Non-critical preference fetching** - Wrapped in try/catch with fallback to prevent blocking on preference fetch failures
- **Parameter threading** - Added timezone as final optional parameter to maintain backwards compatibility
- **Consistent fallback** - Relies on `getTemporalContext()` default rather than duplicating default value

**Learnings:**
1. **Early preference fetch** - Fetching timezone early (right after session capture) ensures it's available for all code paths including tool handling
2. **Silent failure for non-critical data** - Using `console.debug` instead of `console.error` for failed timezone fetch since temporal context still works with default
3. **Long function parameter lists** - Chat API has many optional parameters. Consider refactoring to an options object pattern in future (like `getSystemPromptLayers` already uses)
4. **Two code paths** - Chat API has separate paths for tool-handling and direct response. Both needed timezone threading.

**Quality gates:**
- ✅ npm run check - passes (0 errors, 160 warnings - all pre-existing)
- ⚠️ npm run lint - skipped (pre-existing missing eslint config)

---

### US-007: Add timezone selector to Settings UI (2026-01-16)

**Status:** Completed

**What was done:**
- Added timezone selector section to `src/lib/components/settings/SettingsGeneral.svelte`
- Created dropdown with 14 common timezones (South Africa, Europe, Americas, Asia, Australia, Pacific)
- Shows auto-detected timezone as help text below the dropdown
- Connected to PATCH `/api/user/preferences` for saving
- Updates `userStore` with new preferences after successful save
- Added visual feedback with toast notifications (success/error)
- Styled consistently with existing settings sections

**Files changed:**
- `src/lib/components/settings/SettingsGeneral.svelte` - Added timezone selector section (~120 lines)

**Patterns applied:**
- **Section separation** - Used `border-top` and `margin-top` to visually separate timezone from home page section
- **Existing save pattern** - Followed same fetch → update store → toast pattern used by home page preference
- **onMount for detection** - Used `onMount` to detect browser timezone (client-side only)
- **$effect for sync** - Used `$effect` to sync state when user store changes
- **Graceful fallback** - Falls back to 'Africa/Johannesburg' if timezone detection fails

**Learnings:**
1. **Reuse existing patterns** - Settings page already had a great pattern for saving preferences (fetch, update store, toast). Following it made implementation quick and consistent.
2. **Client-side detection** - Timezone detection must happen in `onMount` since `Intl` APIs are browser-only (not available during SSR)
3. **Common timezone list** - Hardcoded list is fine for MVP. Could expand later with full IANA list or searchable dropdown if users request.
4. **Separate sections visually** - Using `border-top` and `margin-top` creates clear visual hierarchy between unrelated settings sections.

**Quality gates:**
- ✅ npm run check - passes (0 errors, only warnings - all pre-existing)
- ⚠️ npm run lint - skipped (pre-existing missing eslint config)

---

## Feature Complete: Temporal Awareness

**All 7 stories completed!**

### Summary
- Created `getTemporalContext()` function for generating temporal context strings
- Injected temporal context as Layer 0 in system prompt (shouldCache: false)
- Added timezone to UserPreferences type and API validation
- Implemented auto-detection and sync on app load
- Threaded timezone through chat API to prompt builder
- Added timezone selector to Settings UI for manual override

### Next Steps
- Run feature cleanup procedure per prompt.md
- Update AGENTS.md with reusable learnings
- Reset ralph working files for next feature

---
