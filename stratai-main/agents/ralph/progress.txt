# Ralph Progress Log

## Feature: Temporal Awareness
**Parent Task:** temporal-awareness
**Started:** 2026-01-16
**Status:** Ready to begin

## Decisions Made During PRD Creation

- **Where to store timezone**: In UserPreferences JSON field (not a schema change) - follows existing pattern for theme and homePage
- **Default timezone**: Africa/Johannesburg (SAST) - current user base is South Africa
- **Cache Layer 0**: shouldCache: false - temporal context changes daily, small (~50 tokens) so cache miss negligible

## Codebase Patterns Discovered

- `getSystemPromptLayers()` in system-prompts.ts returns PromptLayer[] with name, content, shouldCache
- Platform prompt is currently Layer 1 (will become Layer 1 after temporal is Layer 0)
- UserPreferences is stored as JSONB in users.preferences column
- Preferences API has validation functions per field: validateHomePage(), validateTheme(), validateDefaultModel()
- Layout.svelte uses onMount() for client-side detection (theme sync pattern to follow)
- `Intl.DateTimeFormat().resolvedOptions().timeZone` for browser timezone detection

## Stories

| ID | Title | Status |
|----|-------|--------|
| US-001 | Create getTemporalContext() function in system-prompts.ts | completed |
| US-002 | Inject temporal context as Layer 0 in getSystemPromptLayers() | completed |
| US-003 | Add timezone field to UserPreferences type | completed |
| US-004 | Add timezone validation to preferences API endpoint | completed |
| US-005 | Detect and sync timezone on app load | pending |
| US-006 | Pass timezone to chat API and prompt builder | pending |
| US-007 | Add timezone selector to Settings UI (Optional Phase 3) | pending |

---

## Iteration Log

(Each iteration appends a section below)

---

### US-001: Create getTemporalContext() function (2026-01-16)

**Status:** Completed

**What was done:**
- Created `getTemporalContext(timezone?: string)` function in `src/lib/config/system-prompts.ts`
- Function generates temporal context with current date and timezone for AI prompt injection
- Date formatted as "Thursday, January 16, 2026" using `Intl.DateTimeFormat` with long format
- Timezone display name retrieved using `formatToParts()` to extract timezone name (e.g., "South Africa Standard Time")
- Output wrapped in `<temporal_context>` XML tags as required by acceptance criteria
- Defaults to 'Africa/Johannesburg' when no timezone provided
- Added `DEFAULT_TIMEZONE` constant for consistency

**Files changed:**
- `src/lib/config/system-prompts.ts` - Added getTemporalContext() function (~55 lines)

**Patterns applied:**
- Used `Intl.DateTimeFormat` for internationalization-friendly date/time formatting
- Used `formatToParts()` to extract specific parts (timeZoneName) without parsing strings
- Added JSDoc with examples for clear API documentation
- Followed existing code style with explicit type annotations

**Learnings:**
1. **Intl.DateTimeFormat.formatToParts()** - More robust than parsing formatted strings when you need specific parts like timezone name
2. **timeZoneName: 'long'** option gives full timezone display name (e.g., "South Africa Standard Time" vs just "SAST")
3. **ESLint config missing** - Project has no eslint.config.js file, so `npm run lint` fails. Pre-existing issue, not introduced by this change.

**Quality gates:**
- ✅ npm run check - passes (0 errors)
- ⚠️ npm run lint - skipped (pre-existing missing eslint config)
- ✅ Prettier formatting applied

---

### US-002: Inject temporal context as Layer 0 (2026-01-16)

**Status:** Completed

**What was done:**
- Modified `getSystemPromptLayers()` to accept new `timezone` option parameter
- Injected temporal layer as the FIRST layer (Layer 0) before platform prompt
- Temporal layer properties: `name: 'temporal'`, `shouldCache: false`
- Platform prompt shifted from Layer 1 to Layer 1 (unchanged number, but now after temporal)
- Context layer is now Layer 2 (after temporal and platform)
- Updated JSDoc comments to reflect new layer ordering

**Files changed:**
- `src/lib/config/system-prompts.ts` - Modified getSystemPromptLayers() function (~20 lines added)

**Patterns applied:**
- Followed existing PromptLayer interface pattern (name, content, shouldCache)
- Used consistent pattern with `options.timezone` optional parameter
- Maintained backwards compatibility (timezone defaults to 'Africa/Johannesburg' via getTemporalContext)

**Learnings:**
1. **Layer ordering matters for prompt caching** - Temporal goes first because it changes most frequently (daily), which means cache invalidation propagates correctly. Putting it at the end would waste caching for stable layers.
2. **shouldCache: false is correct** - Small layer (~50 tokens), changes daily. Cache miss cost is negligible compared to maintaining cache freshness for time-sensitive content.
3. **Options object pattern** - Function already used options object, making it easy to add new optional parameters without breaking existing callers.

**Quality gates:**
- ✅ npm run check - passes (0 errors, only warnings)
- ⚠️ npm run lint - skipped (pre-existing missing eslint config)

---

---

### US-003: Add timezone field to UserPreferences type (2026-01-16)

**Status:** Completed

**What was done:**
- Added `timezone?: string` field to the `UserPreferences` interface in `src/lib/types/user.ts`
- Added JSDoc documentation explaining the IANA timezone format and usage
- Examples in JSDoc: 'Africa/Johannesburg', 'America/New_York', 'Europe/London'

**Files changed:**
- `src/lib/types/user.ts` - Added timezone field to UserPreferences interface (~6 lines)

**Patterns applied:**
- Followed existing optional field pattern from `theme`, `homePage`, `defaultModel`
- Used JSDoc with examples to document the expected format (IANA timezone strings)
- Kept the change minimal - just the type definition, no database changes needed since UserPreferences is stored as JSONB

**Learnings:**
1. **UserPreferences stored as JSONB** - No migration needed for new preference fields since they're stored in a JSON column. Just add to the TypeScript interface.
2. **IANA timezone format** - Industry standard format (e.g., 'Africa/Johannesburg') used by JavaScript's `Intl` APIs. Browser-detectable via `Intl.DateTimeFormat().resolvedOptions().timeZone`.
3. **Simple stories matter** - Even a 6-line change is a discrete unit of work that can be tested and committed independently. Sets up foundation for US-004 (validation) and US-005 (detection).

**Quality gates:**
- ✅ npm run check - passes (0 errors, 160 warnings - all pre-existing)
- ⚠️ npm run lint - skipped (pre-existing missing eslint config)

---

### US-004: Add timezone validation to preferences API endpoint (2026-01-16)

**Status:** Completed

**What was done:**
- Added `validateTimezone()` function to `src/routes/api/user/preferences/+server.ts`
- Uses `Intl.DateTimeFormat` to validate IANA timezone strings at runtime
- Updated PATCH handler to accept `body.timezone` and call validation
- Invalid timezone returns 400 with `validation_error` type (follows existing pattern)
- Updated JSDoc for PATCH handler to include timezone parameter

**Files changed:**
- `src/routes/api/user/preferences/+server.ts` - Added validateTimezone() function (~25 lines) and PATCH handler timezone handling (~10 lines)

**Patterns applied:**
- Followed existing validation pattern from `validateTheme()` and `validateDefaultModel()`
- Used `Intl.DateTimeFormat` for timezone validation (throws on invalid timezone)
- Consistent error response format with `{ message, type: 'validation_error' }`
- JSDoc examples for clarity on expected input/output

**Learnings:**
1. **Intl.DateTimeFormat for timezone validation** - Passing an invalid timezone to `{ timeZone: value }` option throws a RangeError. This is the cleanest way to validate IANA timezone strings without maintaining a hardcoded list.
2. **Pattern consistency matters** - Following the exact same pattern as existing validators (validateTheme, validateHomePage) makes the code predictable and easy to review.
3. **Error message format** - Using `type: 'validation_error'` allows clients to differentiate between validation errors (user fixable) and server errors (not user fixable).

**Quality gates:**
- ✅ npm run check - passes (0 errors, 160 warnings - all pre-existing)
- ⚠️ npm run lint - skipped (pre-existing missing eslint config)

---
